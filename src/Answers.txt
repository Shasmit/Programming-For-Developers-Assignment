1. 
// You are provided with kth linked list. Write an algorithm to find median of merged linked
// list in sorter order.
// input: list 1= [2,4,7,5,10]
// list2 = [3,2,7,9]
// list3 = [12,5,6,9]
// output: 6
// Explanation:
// after merging above kth linked list i.e three list in sorted order linked list become,
// [2,2,3,4,5,5,6,7,7,9,9,10,12] 

package Week1;

import Week1.SingelyLinkedList.Node;

public class kLinkedList {

    SingelyLinkedList[] arr; // This array stores all the linked lists user inputs.

    kLinkedList(SingelyLinkedList[] arr) {
        // constructor
        this.arr = arr;
    }

    SingelyLinkedList MergeAll() {
        // This function itterates through all the linked lists and merges them into one
        // linked list.
        SingelyLinkedList FinalOutputList = arr[0]; // Initialize the final output list with the first linked list.
        SingelyLinkedList mergedList; // This linked list is used to store the two merged linked list.
        for (int i = 1; i < arr.length; i++) {
            // itteration through all the linked lists.
            mergedList = MergeTwo(FinalOutputList, arr[i]); // Merge the current linked list with the final output list.
            FinalOutputList = mergedList; // Update the final output list with the merged linked list.
        }
        return FinalOutputList; // Return the final output list.
    }

    SingelyLinkedList MergeTwo(SingelyLinkedList a, SingelyLinkedList b) {
        // This function merges two linked lists.
        SingelyLinkedList result = new SingelyLinkedList(); // Initialize the result linked list.
        Node first_itterator = a.head; // Initialize the first itterator with the first linked list.
        Node second_itterator = b.head; // Initialize the second itterator with the second linked list.
        while (first_itterator != null) {
            // itterate through the first linked list.
            result.addNode(first_itterator.data); // Append the current data to the result linked list.
            first_itterator = first_itterator.next; // Update the first itterator.
        }
        while (second_itterator != null) {
            // itterate through the second linked list.
            result.addNode(second_itterator.data); // Append the current data to the result linked list.
            second_itterator = second_itterator.next; // Update the second itterator.
        }
        return sortLinkedList(result); // Return the sorted result linked list.
    }

    SingelyLinkedList sortLinkedList(SingelyLinkedList list) {
        // Node current will point to head
        Node current = list.head, index = null; // Initialize the current and index pointers.
        int temp; // Initialize the temp variable.

        if (list.head == null) {
            return null; // If the linked list is empty, return null.
        } else {
            while (current != null) {
                // Node index will point to node next to current
                index = current.next;

                while (index != null) {
                    // If current node's data is greater than index's node data, swap the data
                    // between them
                    if (current.data > index.data) {
                        temp = current.data;
                        current.data = index.data;
                        index.data = temp;
                    }
                    index = index.next;
                }
                current = current.next;
            }
        }
        return list; // Return the sorted linked list.
    }

    void Median() {

        int median = (MergeAll().getSize()+1) / 2; 
        // Get the median of the linked list.
        System.out.println("Median: " + MergeAll().getDataAtAnyPos(median)); // Print the median.
    }

    public static void main(String[] args) {
        //creating 3 linked lists
        SingelyLinkedList[] arr = new SingelyLinkedList[3];
        SingelyLinkedList L1 = new SingelyLinkedList();
        SingelyLinkedList L2 = new SingelyLinkedList();
        SingelyLinkedList L3 = new SingelyLinkedList();

        //adding nodes to the linked lists
        L1.addNode(2);
        L1.addNode(4);
        L1.addNode(7);
        L1.addNode(5);
        L1.addNode(10);
        L2.addNode(3);
        L2.addNode(2);
        L2.addNode(7);
        L2.addNode(9);
        L3.addNode(12);
        L3.addNode(5);
        L3.addNode(6);
        L3.addNode(9);
        //passing the linked lists as arrays
        arr[0] = L1;
        arr[1] = L2;
        arr[2] = L3;
        kLinkedList w = new kLinkedList(arr);
        //displaying the output
        w.Median();
        
    }
}


package Week1;
public class SingelyLinkedList {

    public static class Node{
        Node next;
        int data;
        Node(int data){
            this.data= data;
            this.next= null;
        }
    }
    Node head= null;
    Node tail= null;
    int size = 0;

    public void addNode(int data){
        size++;
        Node newnode = new Node(data);
        if(head == null){
            head = tail= newnode;
        }
        else{
            tail.next = newnode;
            tail = newnode;
        }

    }

    public int getSize(){
        return size;
    }

    public void printSinglyLinkedList() {
        if (!isEmpty()) {
            Node current = head;

            // System.out.print("graph.SinglyLinkedList: ");
            while (current.next != null) {
                System.out.print(current.data + " -> ");
                current = current.next;
            }
            System.out.print(current.data);
            System.out.println();
        }
    }


    boolean isEmpty() {
        return head == null;
    }

    public int getDataAtAnyPos(int pos){
        Node current = head;
        for(int i=1; i<=pos; i++){
            current = current.next;
        }
        return current.data;
    }

}




4.
public class Week4 {
    // sorting array
    private static void sortArray(int array[]) {
        for (int i = 1; i < array.length; i++) {
            int j = i;
            int a = array[i];
            while ((j > 0) && (array[j - 1] > a)) {
                array[j] = array[j - 1];
                j--;
            }
            array[j] = a;
        }
    }

    public static void main(String[] args) {
        int i;
        int totalContainers = 0;

        // initializing an array
        int array[] = { 5, 2, 2, 2, 4, 6 };

        // sorting the array
        sortArray(array);

        int prevValue = 0;
        int containerForCurrentVillage = 0;

        for (i = 0; i < array.length; i++) {
            if (array[i] != prevValue) {
                prevValue = array[i];
                containerForCurrentVillage += 1;
                totalContainers += containerForCurrentVillage;
            } else {
                prevValue = array[i];
                totalContainers += containerForCurrentVillage;
            }
        }

        System.out.println(totalContainers);
    }
}



5.
public class Week5 {
    public static void checkSubset(String target, String[] set) {
        String visited = "";

        int ans = 0;

        for (int i = 0; i < target.length(); i++) {
            for (int j = 0; j < set.length; j++) {
                for (int k = 0; k < set[j].length(); k++) {
                    if (target.toUpperCase().charAt(i) == set[j].toUpperCase().charAt(k)
                            && !visited.contains(target.charAt(i) + "")) {
                        visited += target.charAt(i);

                        // System.out.println(target.charAt(i));
                        // System.out.println(set[j]);

                        if (ans <= j + 1) {
                            ans++;
                        }
                    }
                }
            }
        }
        System.out.println("-------------------");

        // for (int i = 0; i < subset.length; i++) {
        // System.out.println(subset[i]);
        // }
        System.out.println(ans);
    }

    public static void main(String[] args) {
        String target = "frog";
        String[] set = { "programming", "For", "developers" };
        checkSubset(target, set);
    }
}



7. 
package Week7;

class Grid {

    static int UniquePathHelper(int i, int j, int m, int n,
                                int[][] A)
    {
        // boundary condition or constraints
        if (i == m || j == n) {
        return 0;
        }
    
        if (A[i][j] == 1) {
        return 0;
        }
    
        // base case
        if (i == m - 1 && j == n - 1) {
        return 1;
        }
    
        return UniquePathHelper(i + 1, j, m, n, A)
        + UniquePathHelper(i, j + 1, m, n, A);
    }
    
    static int uniquePathsWithObstacles(int[][] A)
    {
    
        int m = A.length, n = A[0].length;
    
        return UniquePathHelper(0, 0, m, n, A);
    }
    
    // Driver Code
    public static void main(String[] args)
    {
        int[][] A
        = { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 0, 0 } };
    
        System.out.print(uniquePathsWithObstacles(A));
    }
}
